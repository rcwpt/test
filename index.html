<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Particle System</title>
    
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
        }

        #loading-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.5s;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #a855f7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Hide video element, we only need the data */
        .input_video { display: none; }
        
        /* Mirror the gesture feedback preview */
        .camera-preview {
            transform: scaleX(-1); 
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader mb-4"></div>
        <h2 class="text-white text-xl font-light tracking-widest">INITIALIZING SYSTEMS</h2>
        <p class="text-gray-400 text-sm mt-2">Please allow camera access</p>
        <button id="start-btn" class="hidden mt-6 px-6 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-full transition">START EXPERIENCE</button>
    </div>

    <!-- Main UI Overlay -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-6">
        
        <!-- Header -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div>
                <h1 class="text-white text-2xl font-bold tracking-tighter">PARTICLE<span class="text-purple-400">FLOW</span></h1>
                <p class="text-gray-400 text-xs uppercase tracking-widest">Gesture Interactive System</p>
            </div>
            
            <!-- Camera Preview (Small) -->
            <div class="glass-panel p-1 w-32 h-24 overflow-hidden relative">
                <canvas id="camera-canvas" class="camera-preview w-full h-full object-cover"></canvas>
                <div class="absolute bottom-1 left-1 bg-black/50 text-[10px] text-white px-1 rounded">CAM FEED</div>
            </div>
        </div>

        <!-- Gesture Instructions -->
        <div class="absolute top-1/2 right-6 transform -translate-y-1/2 flex flex-col gap-4 items-end pointer-events-none opacity-70">
            <div class="glass-panel p-3 flex items-center gap-3">
                <span class="text-2xl">üñêüèº</span>
                <div class="text-right">
                    <p class="text-white text-xs font-bold">OPEN PALM</p>
                    <p class="text-gray-300 text-[10px]">EXPLODE / DISPERSE</p>
                </div>
            </div>
            <div class="glass-panel p-3 flex items-center gap-3">
                <span class="text-2xl">ü´∂üèº</span>
                <div class="text-right">
                    <p class="text-white text-xs font-bold">TWO HANDS</p>
                    <p class="text-gray-300 text-[10px]">FORM SHAPE (LOVE)</p>
                </div>
            </div>
            <div class="glass-panel p-3 flex items-center gap-3">
                <span class="text-2xl">‚úäüèº</span>
                <div class="text-right">
                    <p class="text-white text-xs font-bold">CLOSED FIST</p>
                    <p class="text-gray-300 text-[10px]">CONDENSE / SPHERE</p>
                </div>
            </div>
        </div>

        <!-- Controls Footer -->
        <div class="flex flex-wrap gap-4 items-end pointer-events-auto">
            <!-- Pattern Controls -->
            <div class="glass-panel p-4 flex flex-col gap-2 min-w-[200px]">
                <label class="text-white text-xs font-bold uppercase mb-1">Shape Select</label>
                <div class="flex gap-2">
                    <button onclick="setShape('sphere')" class="px-3 py-1 bg-white/10 hover:bg-white/20 text-white text-xs rounded transition">Sphere</button>
                    <button onclick="setShape('heart')" class="px-3 py-1 bg-white/10 hover:bg-white/20 text-white text-xs rounded transition">Heart</button>
                    <button onclick="setShape('cube')" class="px-3 py-1 bg-white/10 hover:bg-white/20 text-white text-xs rounded transition">Cube</button>
                </div>
            </div>

            <!-- Color Picker -->
            <div class="glass-panel p-4 flex flex-col gap-2">
                <label class="text-white text-xs font-bold uppercase mb-1">Particle Color</label>
                <div class="flex items-center gap-3">
                    <input type="color" id="color-picker" value="#a855f7" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                    <span id="color-hex" class="text-white text-xs font-mono">#A855F7</span>
                </div>
            </div>

            <div class="flex-grow"></div>

            <!-- Fullscreen -->
            <button onclick="toggleFullscreen()" class="glass-panel p-3 hover:bg-white/20 text-white transition">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1h-4m4 0v4m0-4l-5 5M4 16v4m0 0h4M4 20l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Hidden Video Input -->
    <video class="input_video"></video>

    <!-- Three.js Canvas Container -->
    <div id="canvas-container" class="w-full h-screen"></div>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 3000;
        const PARTICLE_SIZE = 0.15;
        const DISPERSION_FORCE = 8;
        
        let scene, camera, renderer, particles;
        let positions, targetPositions, originalPositions; // Float32Arrays
        let mouseX = 0, mouseY = 0;
        let currentShape = 'sphere';
        let isExploded = false;
        
        // --- THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // Add some fog for depth
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Create Particles
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            
            // Initial Shape: Sphere
            calculateSpherePositions(targetPositions);
            
            // Set initial positions to target
            for(let i=0; i<targetPositions.length; i++) {
                positions[i] = targetPositions[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Generate a soft glow texture
            const sprite = getTexture();

            const material = new THREE.PointsMaterial({
                color: 0xa855f7,
                size: PARTICLE_SIZE,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Lights (for aesthetic, though points material is unlit)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
        }

        // --- PARTICLE SHAPE LOGIC ---
        
        function calculateSpherePositions(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 4 + (Math.random() * 0.5); // Radius 4 with some variation

                arr[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                arr[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                arr[i * 3 + 2] = r * Math.cos(phi);
            }
        }

        function calculateCubePositions(arr) {
            const side = 6;
            const half = side / 2;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                arr[i * 3] = (Math.random() * side) - half;
                arr[i * 3 + 1] = (Math.random() * side) - half;
                arr[i * 3 + 2] = (Math.random() * side) - half;
            }
        }

        // 3D Heart Shape Formula
        function calculateHeartPositions(arr) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart formula variation
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI;
                
                // Distribute points somewhat evenly? 
                // Let's use rejection sampling or a specific parametric equation
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                // z = thickness variation
                
                // Better 3D heart approximation
                const x = (Math.random() * 4) - 2; 
                const y = (Math.random() * 4) - 2; 
                const z = (Math.random() * 4) - 2; 

                // We will iterate until we fill the array, simplified here by just calculating
                // parametric distribution
                
                // Using a known parametric heart loop for cleaner lines + volume
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                // Scale factor
                const s = 0.35;

                // Formula: (x^2 + 9/4y^2 + z^2 - 1)^3 - x^2z^3 - 9/80y^2z^3 = 0
                // This is hard to generate random points on surface.
                
                // Simple Parametric Heart Curve (2D extruded with noise)
                const t_val = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t_val), 3);
                let hy = 13 * Math.cos(t_val) - 5 * Math.cos(2 * t_val) - 2 * Math.cos(3 * t_val) - Math.cos(4 * t_val);
                
                // Add volume (Z) and some randomness inside
                let hz = (Math.random() * 6) - 3;
                
                // Scale it down
                arr[i * 3] = hx * s;
                arr[i * 3 + 1] = hy * s;
                arr[i * 3 + 2] = hz;
            }
        }

        function explodeParticles() {
            if (isExploded) return;
            const temp = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // Direction vector from center
                const x = targetPositions[i*3];
                const y = targetPositions[i*3+1];
                const z = targetPositions[i*3+2];
                
                // Explode outwards based on current shape position
                temp[i*3] = x * DISPERSION_FORCE + (Math.random() - 0.5) * 5;
                temp[i*3+1] = y * DISPERSION_FORCE + (Math.random() - 0.5) * 5;
                temp[i*3+2] = z * DISPERSION_FORCE + (Math.random() - 0.5) * 5;
            }
            // Use tweening logic in animate loop, just update target here
            // Note: For explosion, we might want to override the 'shape' target temporarily
            // But to keep it simple, we will calculate 'explosion' targets
            
            // Actually, let's just multiply current targets by a scalar for the explosion effect
            // We handle this in the update logic
            isExploded = true;
        }

        function condenseParticles() {
            isExploded = false;
        }

        function setShape(shapeName) {
            currentShape = shapeName;
            if (shapeName === 'sphere') calculateSpherePositions(targetPositions);
            else if (shapeName === 'cube') calculateCubePositions(targetPositions);
            else if (shapeName === 'heart') calculateHeartPositions(targetPositions);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsAttribute = particles.geometry.attributes.position;
            const currentPos = positionsAttribute.array;

            // Rotate entire system slowly
            particles.rotation.y += 0.002;
            particles.rotation.x += (mouseY * 0.001 - particles.rotation.x) * 0.1;
            particles.rotation.y += (mouseX * 0.001 - particles.rotation.y) * 0.1;

            // Particle Movement Logic
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let tx = targetPositions[i * 3];
                let ty = targetPositions[i * 3 + 1];
                let tz = targetPositions[i * 3 + 2];

                if (isExploded) {
                    // If exploded, target is far away
                    tx *= 3;
                    ty *= 3;
                    tz *= 3;
                }

                // Lerp (Linear Interpolation) for smooth transition
                // Speed depends on state (explosion is faster)
                const speed = isExploded ? 0.08 : 0.04;
                
                currentPos[i * 3] += (tx - currentPos[i * 3]) * speed;
                currentPos[i * 3 + 1] += (ty - currentPos[i * 3 + 1]) * speed;
                currentPos[i * 3 + 2] += (tz - currentPos[i * 3 + 2]) * speed;
            }

            positionsAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE LOGIC ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('camera-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // Draw MediaPipe Visuals to the mini-canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                }
                
                // --- GESTURE RECOGNITION ---
                const hands = results.multiHandLandmarks;
                
                // 1. Check for Two Hands (Heart Mode)
                if (hands.length === 2) {
                    // Simple heuristic: Two hands detected = User trying to do something complex/Love
                    // Refinement: Check if hands are somewhat close? 
                    // For UI responsiveness, immediate feedback on 2 hands is satisfying.
                    
                    if (currentShape !== 'heart') {
                        setShape('heart');
                        condenseParticles();
                        showFeedback('LOVE MODE ACTIVATED');
                    }
                } 
                else if (hands.length === 1) {
                    // Single Hand Logic
                    const lm = hands[0];
                    
                    // Detect Open vs Closed
                    // Calculate distance between Wrist (0) and Middle Finger Tip (12)
                    // normalize by bounding box scale ideally, but simple Euclidean is fine for fixed camera
                    const wrist = lm[0];
                    const middleTip = lm[12];
                    const thumbTip = lm[4];
                    const indexTip = lm[8];

                    // Distance helper
                    const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                    const handSpan = dist(wrist, middleTip);
                    const thumbIndexDist = dist(thumbTip, indexTip);

                    // Thresholds (empirically determined)
                    // HandSpan > 0.3 usually means open hand
                    // ThumbIndexDist < 0.05 usually means pinch/fist
                    
                    if (handSpan > 0.35) {
                        // Open Hand -> Explode
                        if (!isExploded) {
                            explodeParticles();
                            showFeedback('EXPLOSION');
                        }
                    } else if (handSpan < 0.25) {
                        // Closed/Relaxed -> Condense
                        if (isExploded || currentShape === 'heart') {
                            condenseParticles();
                            if(currentShape === 'heart') setShape('sphere'); // Reset to sphere on fist
                            // showFeedback('CONDENSE');
                        }
                    }
                    
                    // Fallback to Sphere if we came from Heart and now only have 1 hand
                    if (currentShape === 'heart' && !isExploded) {
                        setShape('sphere');
                    }
                }
            } else {
                // No hands? Reset to chill sphere
                if(isExploded) condenseParticles();
                if(currentShape !== 'sphere') setShape('sphere');
            }
            
            canvasCtx.restore();
        }

        // --- INITIALIZATION FLOW ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320, // Low res for processing speed
            height: 240
        });

        // Event Listeners
        const startBtn = document.getElementById('start-btn');
        const loader = document.querySelector('.loader');
        
        // Show start button after a brief fake load or when assets ready
        setTimeout(() => {
            loader.style.display = 'none';
            startBtn.classList.remove('hidden');
        }, 1500);

        startBtn.addEventListener('click', () => {
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 500);

            initThree();
            animate();
            cameraUtils.start();
        });

        // UI Helpers
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) / 2;
            mouseY = (event.clientY - window.innerHeight / 2) / 2;
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        function showFeedback(text) {
            // Optional: Console log or on-screen toast if needed
            // console.log(text);
        }

        // Color Picker Logic
        const colorPicker = document.getElementById('color-picker');
        const colorHex = document.getElementById('color-hex');
        
        colorPicker.addEventListener('input', (e) => {
            const color = e.target.value;
            colorHex.innerText = color.toUpperCase();
            if(particles) {
                particles.material.color.set(color);
            }
        });

    </script>
</body>
</html>
