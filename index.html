<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Magic - Interactive Particles</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js & Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- FontLoader & TextGeometry for Text Rendering -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease-out;
        }

        .loader {
            width: 50px; height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%; border-top-color: #ec4899;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .input_video { display: none; }
        .camera-preview { transform: scaleX(-1); border-radius: 12px; border: 1px solid rgba(255,255,255,0.2); }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader mb-6"></div>
        <h2 class="text-white text-2xl font-light tracking-[0.2em]">LOADING ASSETS</h2>
        <p class="text-gray-500 text-sm mt-2">Loading Fonts & AI Models...</p>
        <button id="start-btn" class="hidden mt-8 px-8 py-3 bg-gradient-to-r from-pink-500 to-purple-600 text-white rounded-full font-bold tracking-wider hover:scale-105 transition shadow-[0_0_20px_rgba(236,72,153,0.5)]">START MAGIC</button>
    </div>

    <!-- UI Overlay -->
    <div class="absolute inset-0 pointer-events-none z-10 p-6 flex flex-col justify-between">
        
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="pointer-events-auto">
                <h1 class="text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-purple-400 text-3xl font-bold">GESTURE<span class="text-white font-thin">PARTICLES</span></h1>
                <p class="text-gray-400 text-xs tracking-widest mt-1">AI POWERED EMOTION SYSTEM</p>
            </div>
            <div class="glass-panel p-1 w-32 h-24 relative pointer-events-auto">
                <canvas id="camera-canvas" class="camera-preview w-full h-full object-cover"></canvas>
            </div>
        </div>

        <!-- Gesture Guide (Right Side) -->
        <div class="absolute top-1/2 right-6 -translate-y-1/2 flex flex-col gap-4 items-end opacity-80">
            
            <div class="glass-panel p-3 flex items-center gap-4 transition hover:scale-105">
                <span class="text-3xl">ü´∞üèº</span>
                <div class="text-right">
                    <p class="text-pink-400 text-xs font-bold">FINGER HEART</p>
                    <p class="text-white text-[10px]">"I LOVE YOU"</p>
                </div>
            </div>

            <div class="glass-panel p-3 flex items-center gap-4 transition hover:scale-105">
                <span class="text-3xl">üëçüèº</span>
                <div class="text-right">
                    <p class="text-blue-400 text-xs font-bold">THUMBS UP</p>
                    <p class="text-white text-[10px]">"I MISS YOU"</p>
                </div>
            </div>

            <div class="glass-panel p-3 flex items-center gap-4 transition hover:scale-105">
                <span class="text-3xl">ü´∂üèº</span>
                <div class="text-right">
                    <p class="text-yellow-400 text-xs font-bold">TWO HANDS</p>
                    <p class="text-white text-[10px]">RAINBOW LOVE</p>
                </div>
            </div>

            <div class="glass-panel p-3 flex items-center gap-4 transition hover:scale-105">
                <span class="text-3xl">‚úäüèº</span>
                <div class="text-right">
                    <p class="text-purple-400 text-xs font-bold">FIST</p>
                    <p class="text-white text-[10px]">RESET SPHERE</p>
                </div>
            </div>
        </div>

        <!-- Footer Status -->
        <div class="text-center w-full">
            <p id="status-text" class="text-white/50 text-sm font-mono tracking-widest uppercase">Waiting for Gesture...</p>
        </div>
    </div>

    <video class="input_video"></video>
    <div id="canvas-container" class="w-full h-screen"></div>

    <script>
        // --- CONSTANTS ---
        const PARTICLE_COUNT = 4000;
        const PARTICLE_SIZE = 0.12;
        
        // --- VARIABLES ---
        let scene, camera, renderer, particles, geometry;
        let positions, targetPositions, colors;
        let loadedFont = null;
        let currentMode = 'sphere'; // sphere, love_text, miss_text, rainbow_heart
        let time = 0;

        // --- INIT THREE.JS ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Initialize Arrays
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);

            // Default Shape: Sphere
            calculateSpherePositions();
            
            // Set initial positions
            for(let i=0; i<targetPositions.length; i++) {
                positions[i] = targetPositions[i];
            }
            
            // Initial Colors (Purple/Blue)
            // Note: particles object is not created yet, so updateColors needs to handle that safely
            updateColors('sphere');

            // Geometry Setup
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Texture
            const sprite = getTexture();

            // Material with Vertex Colors
            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true, // IMPORTANT: Enables individual particle colors
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
            
            // Load Font
            const loader = new THREE.FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                loadedFont = font;
                console.log("Font Loaded");
                enableStart();
            });
        }

        // --- SHAPE CALCULATIONS ---

        function calculateSpherePositions() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 6;

                targetPositions[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                targetPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                targetPositions[i * 3 + 2] = r * Math.cos(phi);
            }
        }

        function calculateHeartPositions(scale = 0.3) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart Surface Parametric Equation
                const t = Math.random() * Math.PI * 2;
                const u = Math.random() * Math.PI; // randomness for volume
                
                // Classic Heart Curve
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4; // Thickness

                // Scatter filling
                const r = Math.random();
                targetPositions[i * 3] = x * scale * r;
                targetPositions[i * 3 + 1] = y * scale * r;
                targetPositions[i * 3 + 2] = z * scale;
            }
        }

        function calculateTextPositions(text) {
            if (!loadedFont) return;

            const textGeo = new THREE.TextGeometry(text, {
                font: loadedFont,
                size: 2.5,
                height: 0.5,
                curveSegments: 4, // Low segments to save perf
                bevelEnabled: false
            });

            textGeo.center();
            
            // We need to sample points from the generated geometry vertices
            // Since particle count is fixed (4000), we loop through text vertices
            const textVerts = textGeo.attributes.position.array;
            const textCount = textVerts.length / 3;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Modulo to wrap around if particles > vertices
                const vIndex = i % textCount; 
                
                // Add some jitter so they aren't perfectly aligned on vertices
                const jitter = 0.05;

                targetPositions[i * 3] = textVerts[vIndex * 3] + (Math.random()-0.5)*jitter;
                targetPositions[i * 3 + 1] = textVerts[vIndex * 3 + 1] + (Math.random()-0.5)*jitter;
                targetPositions[i * 3 + 2] = textVerts[vIndex * 3 + 2] + (Math.random()-0.5)*jitter;
            }
        }

        // --- COLOR LOGIC (AUTO INTERACTIVE) ---

        function updateColors(mode) {
            // FIX: Don't try to access particle attributes if they don't exist yet
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = positions[i*3];
                const y = positions[i*3+1];
                
                let r, g, b;

                if (mode === 'rainbow_heart') {
                    // "Berjuta Warna" - Noise based on position + time
                    // We calculate this in animate loop for shifting effect, 
                    // but set base here.
                    const hue = (i / PARTICLE_COUNT + time * 0.2) % 1;
                    const color = new THREE.Color();
                    color.setHSL(hue, 1.0, 0.6);
                    r = color.r; g = color.g; b = color.b;
                } 
                else if (mode === 'love_text') {
                    // Pink / Red Gradient
                    const color = new THREE.Color();
                    // Gradient from bottom to top
                    const hue = 0.9 + (y * 0.02); // Red/Pink range
                    color.setHSL(hue % 1, 0.9, 0.6);
                    r = color.r; g = color.g; b = color.b;
                }
                else if (mode === 'miss_text') {
                    // Blue / Cyan / White Gradient
                    const color = new THREE.Color();
                    const hue = 0.5 + (x * 0.02); // Blue range
                    color.setHSL(hue % 1, 0.8, 0.6);
                    r = color.r; g = color.g; b = color.b;
                }
                else {
                    // Sphere (Default) - Cool Galaxy colors
                    const color = new THREE.Color();
                    color.setHSL(0.6 + Math.random()*0.1, 0.8, 0.5); // Purple/Blue
                    r = color.r; g = color.g; b = color.b;
                }

                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            // Only notify Three.js to update if particles exist
            if (particles && particles.geometry) {
                particles.geometry.attributes.color.needsUpdate = true;
            }
        }

        function animateColors() {
            if (currentMode !== 'rainbow_heart') return;
            if (!particles || !particles.geometry) return; // Safety check

            const colorAttribute = particles.geometry.attributes.color;
            time += 0.01;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Dynamic shifting rainbow
                const hue = (i * 0.0005 + time) % 1; 
                const color = new THREE.Color();
                color.setHSL(hue, 1.0, 0.5); // Saturation 100%, Lightness 50%
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            colorAttribute.needsUpdate = true;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Shape Morphing (Lerp)
            const currentPos = particles.geometry.attributes.position.array;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Faster interpolation for text to make it snappy
                const speed = 0.08; 
                currentPos[i*3] += (targetPositions[i*3] - currentPos[i*3]) * speed;
                currentPos[i*3+1] += (targetPositions[i*3+1] - currentPos[i*3+1]) * speed;
                currentPos[i*3+2] += (targetPositions[i*3+2] - currentPos[i*3+2]) * speed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Rotation (Gentle idle)
            particles.rotation.y += 0.002;

            // Color Animation
            animateColors();

            renderer.render(scene, camera);
        }

        // --- GESTURE RECOGNITION ---
        
        function onResults(results) {
            // Draw preview
            const canvasCtx = document.getElementById('camera-canvas').getContext('2d');
            const canvasEl = document.getElementById('camera-canvas');
            canvasCtx.clearRect(0, 0, canvasEl.width, canvasEl.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasEl.width, canvasEl.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                drawConnectors(canvasCtx, hands[0], HAND_CONNECTIONS, {color: '#ffffff', lineWidth: 1});

                // --- LOGIC ---
                let newMode = currentMode;
                let status = "";

                // 1. Two Hands (ü´∂üèº)
                if (hands.length === 2) {
                    newMode = 'rainbow_heart';
                    status = "SPECIAL LOVE MODE";
                } else {
                    const lm = hands[0];
                    
                    // Helper: Distance
                    const dist = (i1, i2) => {
                        const x = lm[i1].x - lm[i2].x;
                        const y = lm[i1].y - lm[i2].y;
                        return Math.sqrt(x*x + y*y);
                    };

                    // Gesture: THUMBS UP (üëçüèº)
                    // Thumb tip is higher (y is smaller) than Index MCP
                    // Other fingers are curled (Tip y > PIP y)
                    // Note: Y increases downwards in MediaPipe
                    const isThumbUp = lm[4].y < lm[3].y && lm[4].y < lm[8].y && lm[12].y > lm[10].y;
                    
                    // Gesture: PINCH / FINGER HEART (ü´∞üèº)
                    // Thumb tip (4) close to Index tip (8)
                    const isPinch = dist(4, 8) < 0.05;

                    // Gesture: FIST (‚úäüèº)
                    // All fingertips close to wrist(0) or MCPs
                    const isFist = dist(12, 0) < 0.3 && dist(8, 0) < 0.3 && dist(16, 0) < 0.3 && dist(20, 0) < 0.3;

                    if (isThumbUp) {
                        newMode = 'miss_text';
                        status = "I MISS YOU";
                    } else if (isPinch) {
                        newMode = 'love_text';
                        status = "I LOVE YOU";
                    } else if (isFist) {
                        newMode = 'sphere';
                        status = "IDLE SPHERE";
                    }
                }

                // State Change Trigger
                if (newMode !== currentMode) {
                    currentMode = newMode;
                    document.getElementById('status-text').innerText = status;
                    
                    if (currentMode === 'sphere') {
                        calculateSpherePositions();
                        updateColors('sphere');
                    } else if (currentMode === 'rainbow_heart') {
                        calculateHeartPositions(0.4);
                        // Colors handled in animate loop
                    } else if (currentMode === 'love_text') {
                        calculateTextPositions('I Love You');
                        updateColors('love_text');
                    } else if (currentMode === 'miss_text') {
                        calculateTextPositions('I Miss You');
                        updateColors('miss_text');
                    }
                }
            } else {
                // No hands detected
                // Don't auto-reset immediately to keep the last nice message visible for a moment
                // Or reset if you prefer snappy response
            }
        }

        // --- SETUP SYSTEM ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const videoElement = document.getElementsByClassName('input_video')[0];
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        function enableStart() {
            document.querySelector('.loader').style.display = 'none';
            document.querySelector('#loading-screen h2').style.display = 'none';
            document.querySelector('#loading-screen p').style.display = 'none';
            const btn = document.getElementById('start-btn');
            btn.classList.remove('hidden');
            
            btn.addEventListener('click', () => {
                document.getElementById('loading-screen').style.opacity = 0;
                setTimeout(() => document.getElementById('loading-screen').remove(), 800);
                cameraUtils.start();
                animate();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            return new THREE.Texture(canvas);
        }
        
        // Wait for font before init
        initThree();

    </script>
</body>
</html>
